<#
/*
T4 templates are very sensitive to spacing. The overall layout typically looks odd, if the generated code is to be
properly indented. Thus, nearly every source indent and blank line here (or lack thereof) are significant.
Beware trailing whitespace in a line that ends a control block can cause a blank line to appear before the next line.
*/
#>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.IO" #>
<#@ assembly name="System.Xml.dll" #>
<#@ assembly name="System.Xml.Linq.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.IO" #>
<#@ parameter type="System.String" name="T4Prefix" #>
<#@ parameter type="System.String" name="T4XmlFolder" #>
<#@ parameter type="System.String" name="RootNamespace" #>
<#+
    internal class Dimension
    {
        public string Name { get; set; }
    }

    internal class Annotation
    {
        public string Name { get; set; }
    }

    internal class Metric
    {
        public string Name { get; set; }

        public bool LogValueRequired { get; set; }

        public IEnumerable<Dimension> Dimensions { get; set; }

        public IEnumerable<Annotation> Annotations { get; set; }
    }

    void GenerateMetrics(string t4Prefix = default, string rootNamespace = default, string t4XmlFolder = default)
    {
        t4Prefix = t4Prefix ?? T4Prefix ?? Path.GetFileNameWithoutExtension(this.Host.TemplateFile);
        t4XmlFolder = t4XmlFolder ?? T4XmlFolder ?? this.Host.ResolvePath("Metrics");
        rootNamespace = rootNamespace ?? RootNamespace ?? "Telemetry";

        string metricClassName = $"{t4Prefix}Metric";
        string metricNamespace = $"{rootNamespace}.Metrics";
        string[] metricsXmlFullPath = Directory.GetFiles(t4XmlFolder);
        string metricEnumName = $"MetricName";

        var metricsToWrite = new List<Metric>();
        foreach(var metricsXml in metricsXmlFullPath)
        {
            XDocument doc = XDocument.Load(metricsXml);

            foreach (var item in doc.Descendants("Metric"))
            {
                int expectedValue = 0;
                foreach (var d in item.Descendants("Dimension"))
                {
                    int position = int.Parse(d.Attribute("order").Value);
                    if (expectedValue != position)
                    {
                        Error(
                            $"Error: Order value '{position}' is not expected for metric " +
                            $"'{item.Element("Name").Value}'. Expected value: {expectedValue}. Values " +
                            $"should start from 0 and be in increasing order without gaps or duplicates.");
                    }

                    expectedValue++;
                }

                expectedValue = 0;
                foreach (var d in item.Descendants("Annotation"))
                {
                    int position = int.Parse(d.Attribute("order").Value);
                    if (expectedValue != position)
                    {
                        Error(
                            $"Error: Order value '{position}' is not expected for annotation " +
                            $"'{item.Element("Name").Value}'. Expected value: {expectedValue}. Values " +
                            $"should start from 0 and be in increasing order without gaps or duplicates.");
                    }

                    expectedValue++;
                }
            }

            var metrics = from c in doc.Descendants("Metric") select new Metric
            {
                Name = c.Element("Name").Value,
                LogValueRequired = bool.Parse(c.Element("LogValueRequired").Value),
                Dimensions = from x in
                c.Descendants("Dimension").OrderBy(d => int.Parse(d.Attribute("order").Value)) select new Dimension
                {
                    Name = x.Element("Name").Value
                },
                Annotations = from y in
                c.Descendants("Annotation").OrderBy(d => int.Parse(d.Attribute("order").Value)) select new Annotation
                {
                    Name = y.Element("Name").Value
                }
            };

            metricsToWrite.AddRange(metrics);
        }
#>
// <copyright file="<#=metricClassName#>.codegen.cs" company="Microsoft Corporation">
// Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
// <autogenerated />

using System.Collections.Specialized;
using System.Diagnostics.CodeAnalysis;

namespace <#=metricNamespace#>
{
    public class <#=metricClassName#>
    {
        public enum <#=metricEnumName#>
        {
<#+
        foreach (var item in metricsToWrite)
        {
            string name = item.Name;
#>
            <#= name #>,
<#+
        }
#>
        }

        public string Name { get; }

        public long? Value { get; }

        public OrderedDictionary Dimensions { get; }

        public OrderedDictionary Annotations { get; }

        private <#=metricClassName#>(
            <#=metricEnumName#> name,
            OrderedDictionary dimensions,
            OrderedDictionary annotations)
        {
            this.Name = $"{name}";
            this.Dimensions = dimensions;
            this.Annotations = annotations;
        }

        private <#=metricClassName#>(
            <#=metricEnumName#> name,
            long value,
            OrderedDictionary dimensions,
            OrderedDictionary annotations)
        {
            this.Name = $"{name}";
            this.Value = value;
            this.Dimensions = dimensions;
            this.Annotations = annotations;
        }

        public static Dictionary<string, List<string>> Enumerate()
        {
            var metricsToCreate = new Dictionary<string, List<string>>()
            {
<#+
        foreach (var item in metricsToWrite)
        {
            string name = item.Name;
            string parameters = string.Empty;
            if (item.Dimensions.Any())
            {
                parameters = string.Join(
                        ", ",
                        item.Dimensions.Select(x => "\"" + x.Name + "\""));
            }
#>
                {
                    "<#= name#>",
                    new List<string> { <#=parameters#> }
                },
<#+
        }
#>
            };

            return metricsToCreate;
        }
<#+
        foreach (var item in metricsToWrite)
        {
            string name = item.Name;

            string logValueRequired = string.Empty;
            if (item.LogValueRequired)
            {
                logValueRequired = "long logValue";
            }

            string dimensionsInput = string.Empty;
            if (item.Dimensions.Any())
            {
                if (!string.IsNullOrWhiteSpace(logValueRequired))
                {
                    dimensionsInput = ", ";
                }

                dimensionsInput +=
                    "string " +
                    string.Join(
                        ", string ",
                        item.Dimensions.Select(d => char.ToLower(d.Name[0]) + d.Name.Substring(1)));
            }

            string annotationsInput = string.Empty;
            if (item.Annotations.Any())
            {
                annotationsInput = ", string " +
                    string.Join(
                        ", string ",
                        item.Annotations.Select(a => char.ToLower(a.Name[0]) + a.Name.Substring(1)));
            }
#>

        public static <#=metricClassName#> <#= name #>(<#= logValueRequired #><#= dimensionsInput #><#= annotationsInput #>)
        {
            OrderedDictionary annotationsDict = new OrderedDictionary();
<#+
            if (!string.IsNullOrEmpty(annotationsInput))
            {
                foreach (var anItem in item.Annotations.Select(d => d.Name))
                {
                    var dimensionParam = char.ToLower(anItem[0]) +  anItem.Substring(1);
#>
            annotationsDict.Add("<#= anItem #>", <#= dimensionParam #>);
<#+
                }
            }
#>

            OrderedDictionary dimensions = new OrderedDictionary();
<#+
            if (!string.IsNullOrEmpty(dimensionsInput))
            {
                foreach (var dimension in item.Dimensions.Select(d => d.Name))
                {
                    var dimensionParam = char.ToLower(dimension[0]) +  dimension.Substring(1);
#>
            dimensions.Add("<#= dimension #>", <#= dimensionParam #>);
<#+
                }
            }
#>

            return new <#=metricClassName#>(
                <#=metricEnumName#>.<#= name #>,
<#+
            if (item.LogValueRequired)
            {
#>
                logValue,
<#+
            }
#>
                dimensions,
                annotationsDict);
        }
<#+
    }
#>

        public class Annotation
        {
<#+
        foreach (var item in metricsToWrite)
        {
            if (item.Annotations.Any())
            {
                string name = item.Name;
                var parameters = "string " + string.Join(", string ", item.Annotations.Select(d => d.Name));
#>
            [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible", Justification = "Suppress OACR error.")]
            public class <#= name #>
            {
                public <#= name #>(<#= parameters #>)
                {
<#+
                foreach (string anName in item.Annotations.Select(d => d.Name))
                {
#>
                    this.<#= anName #> = <#= anName #>;
<#+
                }
#>
                }

<#+
                foreach (string anName in item.Annotations.Select(d => d.Name))
                {
#>
                public string <#= anName #> { get; set; }
<#+
                }
#>
            }
<#+
            }
        }
#>
        }

        public class Dimension
        {
<#+
        foreach (var item in metricsToWrite)
        {
            if (item.Dimensions.Any())
            {
                string name = item.Name;
#>
            [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible", Justification = "Suppress OACR error.")]
            public static class <#= name #>
            {
<#+
                foreach (string dimensionName in item.Dimensions.Select(d => d.Name))
                {
#>
                public static readonly string <#= dimensionName #> = "<#= dimensionName #>";
<#+
                }
#>
            }
<#+
            }
        }
#>
        }
    }
}
<#+
    }
#>