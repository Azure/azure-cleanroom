# DO NOT EDIT. AUTO-GENERATED CODE.
# Please run tools/generate_models.ps1 to re-generate the file after editing cleanroomspec-openapi.yaml.


# generated by datamodel-codegen:
#   filename:  cleanroomspec-openapi.yaml

from __future__ import annotations

from enum import Enum
from typing import Dict, List, Literal, Optional, Union

from pydantic import BaseModel, Field


class DnsSettings(BaseModel):
    enabled: bool
    port: int


class NetworkEndpoint(BaseModel):
    address: str
    port: int


class SandBoxType(Enum):
    Type_0 = "Type_0"
    None_ = "None"


class InlinePolicy(BaseModel):
    policyDocument: Optional[str] = None


class SecretProtocolType(Enum):
    AzureKeyVault_Secret = "AzureKeyVault_Secret"
    AzureKeyVault_SecureKey = "AzureKeyVault_SecureKey"
    AzureKeyVault_Key = "AzureKeyVault_Key"
    AzureKeyVault_Certificate = "AzureKeyVault_Certificate"


class StoreProtocolType(Enum):
    Azure_BlobStorage = "Azure_BlobStorage"
    Azure_OneLake = "Azure_OneLake"
    Aws_S3 = "Aws_S3"


class ApplicationStoreProtocolType(Enum):
    AzureContainerRegistry = "AzureContainerRegistry"


class StoreType(Enum):
    Azure_BlobStorage = "Azure_BlobStorage"
    Azure_OneLake = "Azure_OneLake"
    Aws_S3 = "Aws_S3"


class SecretStoreType(Enum):
    AzureKeyVault = "AzureKeyVault"


class ApplicationStoreType(Enum):
    AzureContainerRegistry = "AzureContainerRegistry"


class ResourceType(Enum):
    Azure_BlobStorage = "Azure_BlobStorage"
    Azure_OneLake = "Azure_OneLake"
    Aws_S3 = "Aws_S3"
    AzureKeyVault = "AzureKeyVault"
    AzureContainerRegistry = "AzureContainerRegistry"


class AccessPointType(Enum):
    Volume_ReadWrite = "Volume_ReadWrite"
    Volume_ReadOnly = "Volume_ReadOnly"


class ProxyType(Enum):
    SecureVolume__ReadOnly__Azure__OneLake = "SecureVolume__ReadOnly__Azure__OneLake"
    SecureVolume__ReadOnly__Azure__BlobStorage = (
        "SecureVolume__ReadOnly__Azure__BlobStorage"
    )
    SecureVolume__ReadOnly__Aws__S3 = "SecureVolume__ReadOnly__Aws__S3"
    SecureVolume__ReadWrite__Azure__OneLake = "SecureVolume__ReadWrite__Azure__OneLake"
    SecureVolume__ReadWrite__Azure__BlobStorage = (
        "SecureVolume__ReadWrite__Azure__BlobStorage"
    )
    SecureVolume__ReadWrite__Aws__S3 = "SecureVolume__ReadWrite__Aws__S3"
    API = "API"
    SecureAPI = "SecureAPI"


class ProxyMode(Enum):
    Secure = "Secure"
    Open = "Open"


class Requests(BaseModel):
    cpu: float
    memoryInGB: float


class ApplicationResource(BaseModel):
    requests: Requests


class ApplicationStartType(Enum):
    Auto = "Auto"
    Manual = "Manual"


class RuntimeSettings(BaseModel):
    ports: List[int]
    resource: ApplicationResource


class ConsentCheckScope(Enum):
    Execution = "Execution"
    Logging = "Logging"
    Telemetry = "Telemetry"


class ConsentProvider(BaseModel):
    url: str
    method: str
    validResponses: List[int]


class IdentityProtocolType(Enum):
    AzureAD_Federated = "AzureAD_Federated"
    AzureAD_ManagedIdentity = "AzureAD_ManagedIdentity"
    AzureAD_Secret = "AzureAD_Secret"
    Attested_OIDC = "Attested_OIDC"


class SecretType(Enum):
    Secret = "Secret"
    Certificate = "Certificate"
    Key = "Key"


class DatasetFormat(Enum):
    csv = "csv"
    json = "json"
    parquet = "parquet"


class Outbound1(BaseModel):
    enabled: bool
    allowedIPs: List[NetworkEndpoint]


class TcpSettings(BaseModel):
    outbound: Optional[Outbound1] = None


class ProtocolType(Enum):
    AzureAD_Federated = "AzureAD_Federated"
    AzureAD_ManagedIdentity = "AzureAD_ManagedIdentity"
    AzureAD_Secret = "AzureAD_Secret"
    Attested_OIDC = "Attested_OIDC"
    AzureKeyVault_Secret = "AzureKeyVault_Secret"
    AzureKeyVault_SecureKey = "AzureKeyVault_SecureKey"
    AzureKeyVault_Key = "AzureKeyVault_Key"
    AzureKeyVault_Certificate = "AzureKeyVault_Certificate"
    Azure_BlobStorage = "Azure_BlobStorage"
    Azure_OneLake = "Azure_OneLake"
    Aws_S3 = "Aws_S3"
    AzureContainerRegistry = "AzureContainerRegistry"


class ServiceEndpoint(BaseModel):
    protocol: ProtocolType
    url: str
    configuration: Optional[str] = ""


class Resource(BaseModel):
    name: str
    type: ResourceType
    id: str
    provider: ServiceEndpoint


class AttestationBasedTokenIssuer(BaseModel):
    issuer: ServiceEndpoint
    issuerType: Literal["AttestationBasedTokenIssuer"]


class CleanroomSecret(BaseModel):
    secretType: SecretType
    backingResource: Resource


class EncryptionSecret(BaseModel):
    name: str
    secret: CleanroomSecret


class EncryptionSecrets(BaseModel):
    dek: EncryptionSecret
    kek: EncryptionSecret


class CleanRoomSpecification(BaseModel):
    sandbox: Optional[SandboxSettings] = None
    identities: List[Identity]
    datasources: List[AccessPoint]
    datasinks: List[AccessPoint]
    applications: List[Application]
    network: Optional[NetworkSettings] = None
    governance: Optional[GovernanceSettings] = None


class NetworkSettings(BaseModel):
    http: Optional[HttpSettings] = None
    tcp: Optional[TcpSettings] = None
    dns: Optional[DnsSettings] = None


class Inbound(BaseModel):
    enabled: bool
    policy: PrivacyProxySettings


class Outbound(BaseModel):
    enabled: bool
    policy: PrivacyProxySettings


class HttpSettings(BaseModel):
    inbound: Optional[Inbound] = None
    outbound: Optional[Outbound] = None


class SandboxSettings(BaseModel):
    sandboxType: SandBoxType
    privacyPolicy: Optional[Policy] = None
    configuration: Optional[str] = ""


class Policy(BaseModel):
    policy: Optional[Union[InlinePolicy, ExternalPolicy]] = None


class Document(BaseModel):
    documentType: str
    authenticityReceipt: str
    identity: Optional[Identity] = None
    backingResource: Resource


class AccessPoint(BaseModel):
    name: str
    type: AccessPointType
    path: str
    store: Resource
    identity: Identity
    protection: PrivacyProxySettings


class PrivacyProxySettings(BaseModel):
    proxyType: ProxyType
    proxyMode: ProxyMode
    privacyPolicy: Optional[Policy] = None
    configuration: Optional[str] = ""
    encryptionSecrets: Optional[EncryptionSecrets] = None
    encryptionSecretAccessIdentity: Optional[Identity] = None


class Application(BaseModel):
    name: str
    image: Image
    startType: ApplicationStartType
    command: List[str]
    environmentVariables: Dict[str, str]
    datasources: Optional[Dict[str, str]] = None
    datasinks: Optional[Dict[str, str]] = None
    runtimeSettings: RuntimeSettings


class ApplicationEndpoint(BaseModel):
    type: str
    port: int
    protection: PrivacyProxySettings


class ContractValidationEndpoint(BaseModel):
    consentProvider: ConsentProvider
    identity: Identity


class Image(BaseModel):
    executable: Document
    protection: Optional[PrivacyProxySettings] = None
    enforcementPolicy: Policy


class Identity(BaseModel):
    name: str
    clientId: str
    tenantId: str
    tokenIssuer: Union[
        AttestationBasedTokenIssuer,
        SecretBasedTokenIssuer,
        FederatedIdentityBasedTokenIssuer,
    ] = Field(..., discriminator="issuerType")


class SecretBasedTokenIssuer(BaseModel):
    issuer: ServiceEndpoint
    secret: CleanroomSecret
    secretAccessIdentity: Identity
    issuerType: Literal["SecretBasedTokenIssuer"]


class FederatedIdentityBasedTokenIssuer(BaseModel):
    issuer: ServiceEndpoint
    federatedIdentity: Identity
    issuerType: Literal["FederatedIdentityBasedTokenIssuer"]


class ApplicationTelemetry(BaseModel):
    consent: Optional[GovernanceService] = None
    logs: AccessPoint


class InfrastructureTelemetry(BaseModel):
    consent: Optional[GovernanceService] = None
    metrics: AccessPoint
    traces: AccessPoint
    logs: AccessPoint


class Telemetry(BaseModel):
    infrastructure: Optional[InfrastructureTelemetry] = None
    application: Optional[ApplicationTelemetry] = None


class GovernanceSettings(BaseModel):
    consent: Optional[List[GovernanceService]] = None
    audit: Optional[List[GovernanceService]] = None
    telemetry: Optional[Telemetry] = None


class GovernanceService(BaseModel):
    url: str
    method: str
    validResponses: List[int]
    identity: Identity


class DatasetInfo(BaseModel):
    name: str
    schema_: Optional[Dict[str, Dict[str, str]]] = Field(None, alias="schema")
    format: DatasetFormat
    accessPoint: AccessPoint


class ExternalPolicy(Document):
    pass


CleanRoomSpecification.update_forward_refs()
NetworkSettings.update_forward_refs()
Inbound.update_forward_refs()
Outbound.update_forward_refs()
SandboxSettings.update_forward_refs()
Policy.update_forward_refs()
Document.update_forward_refs()
AccessPoint.update_forward_refs()
PrivacyProxySettings.update_forward_refs()
Application.update_forward_refs()
ContractValidationEndpoint.update_forward_refs()
Identity.update_forward_refs()
ApplicationTelemetry.update_forward_refs()
InfrastructureTelemetry.update_forward_refs()
GovernanceSettings.update_forward_refs()
ExternalPolicy.update_forward_refs()
